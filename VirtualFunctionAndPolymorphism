// Introduction
/*

The word polymorphism is mad up of two words: poly and morphism. the word: poly means many and morph means forms. thus, polymorphism is characterstic of being able to assign as different meaning or usage to something in different context. C++ allows a function or an object to have more than one form. The Function contexts. C++ allows a function or an object to have more than one form. the function overloading, operator overloading, function overriding, virtual function are example of polymorphism. In function, two or more function having same name but with different signatures are used. In function overriding, two or more functions, with same name and same signature but one defined in base class and other in child class, are used.
Similarly, in Operator overloading , same operators can be used to act differently according to context.

If there are many forms of same thing, the question arises: " which form is called at what condition?" The correct form of the function in overloaded member functions is called on the basis of matching arguments in argument lists
The compiler knows " Which version of the function is to be called at what time ? " at compiler time and therefore compiler is able to select the appropriate function for a particular call at the compiler time itself. This is called compiler time polymorphism or early binding or static binding or static linking in this type of polymorphism, an object is bount to its function call at compiler time i.e. before runtime.

But in some cases, the compiler doesn't know about the vorrect form of the function to be called. The correct form of the function is selected to call on the basis of context calling object at run time. Thus, if an appropriate member function is selected while a program is running i.e. after compilation time; it is called run time polymorphism or late binding or dynamic binding or dynamic linking. C++ uses concept of virtual function to implement run time polymorphism

Polymorphism -> Compile time -> Function Overloading & operator Overloading
Polymorphism -> Run time  -> Virtual function;

At runtime, when it is known what class objects are under consideration, the appropriate version of the function is invoked. since the function is linked with a particular class much later after the compilation, this process is termed as late binding.
*/

//Virtual Function
/*

A virtual function is a member function declared in a base class with keyword virtual and reference by derived class. When we use same function name ion both base and derived class, the function in base class is declared as virtual function . To createa virtual function. The function declaration in the base class is preceded by keyword virtual. When a class containing virtual function is inherited, the derived classes redefine the virtual function  to perform its own tasks. virtual function implements " one interface Multiple methods " philosophy. When a function is made as virtual, c++ determines " which function to be used?" at the run time on the basis of type of the object pointer to  by the class pointer, rather than the type of the pointer. We know that base class pointer can point object of deriver class Thus, base class pointer can point to any object of derived classes. The correct function is called on the basis of cvontect of class pointer(i.e which object is pointed by base class pointer at particular time). Thus, by making the base class pointer poining to different object, we can execute different version of the virtual function.

virtual means existing in effect but not in reality. A virtual function, then, is one that does not really exist and doesn't perform any task but appears real and useful in  a program. Once a function is declared virtual, it reamains virtual all the way down the inheritance hierarchy from that point even if ti is not declared virtual when a class override in derived class. When a derived lass doesn't define a virtual function, the derived class simply class. when a derived class doesn't define a virtual function, the derived class simply inherits its immediate base class virtual function definition.

*/
//Rules for Virtual functions

1. Should not be static and must be member of a class.

2. May be declared as friend for another class.

3. Object pointer can access virtual function.

4. Constructor can't be declared as virtual, but Destructor can be declared as Virtual.

5. It is also possible to return a value from virtual function like other function.

7. The prototype of virtual functions in base and derived classes should be exactly the same. In case of mismatch, the compiler neglects the virtual function mechanism and treats them as overloaded function.

8. A virtual function in a base class must be defined in the base class, it need not be necessarily redefined in te derived class.

*/

//Justify the statement: " CONSTRUCTORS CANNOT BE DECLARED AS VIRTUAL, BUT DESTRUCTOR CAN BE DECLARED AS VIRTUAL."
/*
Virtual functions in C++ are implementation of run time polymorphism. They will do function overriding. Generally virtual keyword is used in C++ When we need dynamic behavior. It will work ony when object exists where constructors are used to create objects. Constructors will be called at the time of object creation. So, if we define constructor as virtual, it should have existing object to use. But  Constructor is used at thetime of creation og object. Thus, this is contradictory. So, we shoud not use the constructor as virtual. Again, we can't override a constructor. When any method is declared as virtual, it should be overridden in its derived class. Since constructor is used for initializing variables of a class and it can exist only in that class, it can't be overridden in its derived class. Since constructor is used for initializing variables of a class and it can exist ony in that class, it can't be overridden by child class.

We can use virtual destructors because at the time of calling destructor, we have the objects ,So we can use virtual keyword for the Destructors . '
*/

/*
An ABSTRACT CLASS is one whose role is only a foundation for other classes that would need a common behavior or similar characteristics. Therefore, an abstract class is used only as a base class for inheritance. A class is made abstract by declaring it methods as pure virtual methods. No objects of an abstract base class class can be instantiated.

The sole purpose of an abstract class is to provide an appropriate base class from which classes may inherit interface and/or implementation. The opposite of ABSTRACT CLASS is CONCRETE CLASS from which objects can be instantiated.

A class is made abstract by declaring one or more of its virtual function, to be pure.
A pure Virtual function is one with an initializer of = 0 on its declaration as in
        Virtual return_type function(0 = 0 //pure virtual function.

If a class is derived from a class with a pure virtual function, and if no definition as supplied of that pure virtual function in the derived class, & if no definition is supplied of that pure virtual function in the derived class, then that virtual function remains pure in the derived class. Consequently, the derived class is also an abstract class.
Attempting to instantiate an object of abstract class(i.e class that contains one or more pure virtual function) is a syntax error

 Example:
 class Polygon
 {
    protected:
        int width, height;
    public:
        virtual int area() = 0;
 };

 //Characteristics of Abstract Class

 a) Allows base class to provide only an interface for its derived classes.
 b) Prevents anyone from creating an instance of this class.
 c) A class is made abstract by defining at least one virtual function pure.


*/
//Virtual Base class
/*
Parent-> child1 , Parent -> child2
child1->Grandchild, child2 ->Grandchild

Consider a situation, with a base class, parent; two derived classes, Child1 and Child2; and a fourth class, GrandChild, derived from both child1 & child2

As child1 and child2 inherit Parent, they both have copies of parents. However, GrandChild Inherits both Child1 and Child2. This means that ther are two copies of parents in an object of type GrandChild.. The use of member inherited from Parent through child1 and Child2 into virtual base class as below.

class Parent
{
}
class Child: virtual public parent //shares copy of parent
{
}
class Child: Virtual public parent //share copy of parent
{
}
class grandchild: public child1, public child2;
{
}

The use of keyword virtual in these two classes causes them to share a single copy of their base class parent. Now, since there is only one copy of Parent, there is no ambiguity when it is referred to in GrandChild. Here the virtual base class restricts its derived class from having the multiple copies of common ancestor
*/

